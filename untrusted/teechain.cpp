#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <iostream>
#include <fstream>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h> 
#include <unistd.h>
#include <sys/time.h>
#include "time.h"
#include <sstream>
#include <map>
#include <vector>

#include "message.h"
#include "network.h"
#include "teechain.h"
#include "utils.h"

int client_sockfd;
struct sockaddr_in server_addr;
struct hostent *server;

// remote hostname and port for the teechain node to connect to. 
static std::string remote_host(DEFAULT_HOSTNAME);
static int remote_port = 0;

// optional flags to define teechain node properties.
static char initiator = false;
static char use_monotonic_counters = false;
char debug = false;
char in_benchmark = false;

// parsed option index and arguments from cmdline
int opt_idx;
char *opt_arg;

#define BUFFERLEN 4096
byte local_buffer[BUFFERLEN];


void send_buffer(byte* buffer, size_t len) {
    write(client_sockfd, &len, sizeof(size_t));
    write(client_sockfd, buffer, len);
}

byte* recv_buffer(size_t* len) {
    ssize_t n_read = read(client_sockfd, local_buffer, sizeof(size_t));
    if (n_read != sizeof(size_t)) {
        // Shutdown
        printf("[UT] Invalid message header\n");
        untrusted_teechain_exit();
    }
    size_t reply_size = *(size_t*)local_buffer;
    byte* reply = (byte*)malloc(reply_size);
    if (reply == NULL) {
        // Shutdown
        printf("[UT] Message too large\n");
        untrusted_teechain_exit();
    }
    n_read = read(client_sockfd, reply, reply_size);
    if (n_read != reply_size) {
        printf("[UT] Bad message size\n");
        // Shutdown
        untrusted_teechain_exit();
    }

    *len = reply_size;
    return reply;
}

static void parse_opt_init() {
    opt_idx = 0;
    use_monotonic_counters = false;
    initiator = false;
    debug = false;
    remote_host = std::string(DEFAULT_HOSTNAME);
    remote_port = 0;
}

static void parse_opt(std::vector<char*> &opt_vec, std::vector<char*> &opt_res) {
    char ch;
    for (; opt_idx < opt_vec.size(); opt_idx++) {
        if (opt_vec[opt_idx][0] == '-') {
            ch = opt_vec[opt_idx][1];
            switch (ch) {
                case 'm':
                    use_monotonic_counters = true;
                    break;
                case 'd':
                    debug = true;
                    break;
                case 'b':
                    in_benchmark = true;
                    break;
                case 'i':
                    initiator = true;
                    break;
                case 'r':
                    opt_idx++;
                    remote_host = std::string(opt_vec[opt_idx]);
                    opt_idx++;
                    remote_port = atoi(opt_vec[opt_idx]);
                    break;
            }
        } else {
            opt_res.push_back(opt_vec[opt_idx]);
        }
    }
}

static std::string generate_channel_id() {
    std::ostringstream os;
    srand(time(NULL));
    for (int i = 0; i < CHANNEL_ID_LEN; ++i) {
        int digit = rand() % 10;
	    os << digit;
    }
    // std::string generated_channel_id = os.str();
    //log_debug("Generated channel id: %s\n", generated_channel_id.c_str()); 
    return os.str();
}

static bool enough_arguments_for_command(int expected_num_args, int argc) {
    return argc >= 1 + expected_num_args;
}

static int validate_channel_id(std::string channel_id) {
    if (channel_id.length() != CHANNEL_ID_LEN) {
        printf("Given channel id: %s", channel_id.c_str());
        std::cerr << ("Channel id length incorrect.\n");
        return 1;
    }
    return 0;
}

static int validate_amount_to_send(unsigned long long amount) {
    if (amount <= 0) {
        printf("Can only send positive amount!\n");
        return 1;
    }
    return 0;
}

static void usage(void) {
    std::cerr << ("Usage: teechain [command] [options]\n") << std::endl;
    std::cerr << ("Teechain commands: \n"
        "quit:            Quit. \n"
        "primary:         Assigns an existing ghost to become a primary node. \n"
        "                  Contacts localhost at port p to make assignment. \n"
        "setup_deposits:  Gives a primary node the information about the number of deposits the user wishes to make. \n"
        "                  The TEE then returns a set of bitcoin addresses the user should pay into. \n"
        "deposits_made:   Gives the primary node the transaction hash of the transaction that was generated by \n"
        "                  the ownwer and paid the deposits into the primary node's bitcoin account. This requires \n"
        "                  knowing the redeem scripts to spend and the account to return funds to on settlement.\n"
        "                  This is the information presented to counter party, requiring manual verification. \n"
        "add_deposit:     Assigns an unused (but verified) deposit to a channel. When adding a deposit to a channel \n"
        "                  the adding TEE adds the funds before requiring an ack from the remote party. This is \n"
        "                  an optimization, but doesn't break safety. \n"
        "remove_deposit:  Removes an assigned (but unspent) deposit from a channel. The removing TEE *must wait* \n"
        "                  for the remote TEE to ack the removal first, before removing. This is to ensure \n"
        "                  we don't break safety. \n"
        "create_channel:  Creates a channel with a remote party. \n"
        "                  Both sides of the channel must have create called. \n"
        "                  The initiating side will start the message exchange process. \n"
        "                  The add_backup command uses the same message exchange protocol as here. \n"
        "verify_deposits: The manual verification step that must be performed by the user to verify that the \n"
        "                  deposit transactions presented by the remote TEE do actually exist and are actually \n"
        "                  in the blockchain. \n"
        "                  This is called on an individual channel after creation, but before sending can occur. \n"
        "                  We don't yet wait for a secure ack from the remote party (i.e. for them to establish \n"
        "                  the channel on their side -- but this is fine). \n"
        "send:            Sends a payment across a channel to the counterparty. \n"
        "settle_channel:  Generate a transaction that closes a single channel and notifies the counterparty. \n"
        "                  This can only be called on the primary node. \n"
        "return_unused_deposits: Generate a transaction that returns the currently unused deposits. \n"
        "shutdown:        Settle each of the channels individually. Also generate a transaction that returns \n"
        "                  unused deposits back to the owner. \n")  << std::endl;
}

static int primary(std::vector<char*> &opt_vec) {
    struct assignment_msg_t msg;
    msg.msg_op = OP_PRIMARY;
    msg.use_monotonic_counters = use_monotonic_counters;
    msg.benchmark = in_benchmark;
    send_buffer((byte*) &msg, sizeof(assignment_msg_t));
    return 0;
}

static int setup_deposits(std::vector<char*> &opt_vec) {
    if (!enough_arguments_for_command(1, opt_vec.size())) {
        usage();
        return -1;
    }

    unsigned long long num_deposits = strtoull(opt_vec[1], NULL, 10);
    struct setup_deposits_msg_t msg;
    msg.msg_op = OP_TEECHAIN_SETUP_DEPOSITS;
    msg.num_deposits = num_deposits;
    send_buffer((byte*) &msg, sizeof(setup_deposits_msg_t));
    return 0;
}

static int deposits_made(std::vector<char*> &opt_vec) {
    if (!enough_arguments_for_command(6, opt_vec.size())) {
        usage();
        return -1;
    }

    std::string my_address(opt_vec[1]); // my bitcoin address in B58 format to return funds to
    unsigned long long miner_fee_to_pay = strtoull(opt_vec[2], NULL, 10); // miner fee I want to pay
    unsigned long long num_deposits = strtoull(opt_vec[3], NULL, 10); // number of deposits

    // extract deposits one at a time
    std::map<unsigned long long, std::string> deposit_id_to_tx_id;
    std::map<unsigned long long, unsigned long long> deposit_id_to_tx_idx;
    std::map<unsigned long long, unsigned long long> deposit_id_to_amount;
    unsigned int first_deposit_pointer = 4;

    for (unsigned int i = first_deposit_pointer; i < first_deposit_pointer + (num_deposits * 3); i += 3) {
        std::string txid(opt_vec[i]);
        unsigned long long tx_idx = strtoll(opt_vec[i + 1], NULL, 10); // tx index funding enclave for this deposit
        unsigned long long deposit_amount = strtoull(opt_vec[i + 2], NULL, 10); // deposit amount for this deposit
        int deposit_id = (i - first_deposit_pointer) / 3;

        // store deposit into maps
        deposit_id_to_tx_id[deposit_id] = txid;
        deposit_id_to_tx_idx[deposit_id] = tx_idx;
        deposit_id_to_amount[deposit_id] = deposit_amount;
    }

    struct deposits_made_msg_t msg;
    msg.msg_op = OP_TEECHAIN_DEPOSITS_MADE;
    memcpy(msg.my_address, my_address.c_str(), BITCOIN_ADDRESS_LEN);
    msg.miner_fee = miner_fee_to_pay;
    msg.num_deposits = num_deposits;

    for (unsigned int i = 0; i < num_deposits; i++) {
        std::string txid = deposit_id_to_tx_id[i];
        unsigned long long tx_idx = deposit_id_to_tx_idx[i];
        unsigned long long deposit_amount = deposit_id_to_amount[i];

        memcpy(msg.deposits[i].txid, txid.c_str(), BITCOIN_TX_HASH_LEN);
        msg.deposits[i].tx_idx = tx_idx;
        msg.deposits[i].deposit_amount = deposit_amount;
    }

    send_buffer((byte*) &msg, sizeof(deposits_made_msg_t));
    return 0;
}

static int create_channel(std::vector<char*> &opt_vec) {
    if (!enough_arguments_for_command(0, opt_vec.size())) {
        usage();
        return -1;
    }

    // assign the channel a temporary channel id
    std::string channel_id(TEMPORARY_CHANNEL_ID, CHANNEL_ID_LEN);
    if (initiator) {
        channel_id = generate_channel_id();
    }
    if (validate_channel_id(channel_id)) {
        return -1;
    }

    // construct create message with data
    struct create_channel_msg_t msg;
    msg.msg_op = OP_CREATE_CHANNEL;
    memcpy(msg.channel_id, channel_id.c_str(), CHANNEL_ID_LEN);
    msg.initiator = initiator;
    if (initiator) {
        memcpy(msg.remote_host, remote_host.c_str(), remote_host.length());
        msg.remote_host_len = remote_host.length();
        msg.remote_port = remote_port;
    }

    send_buffer((byte*) &msg, sizeof(create_channel_msg_t));
    // wait for xx
    return 0;
}

static int issue_command_for_channel(unsigned int command, std::string channel_id) {
    struct generic_channel_msg_t msg;
    msg.msg_op = command;
    memcpy((char*)msg.channel_id, channel_id.c_str(), CHANNEL_ID_LEN);
    
    send_buffer((byte*) &msg, sizeof(generic_channel_msg_t));
    return 0;
}

static int verify_deposits(std::vector<char*> &opt_vec) {
    if (!enough_arguments_for_command(1, opt_vec.size())) {
        usage();
        return -1;
    }

    if (opt_vec[1][strlen(opt_vec[1]) - 1] == '\n') {
        // printf("switching from \\n to \\0.\n");
        opt_vec[1][strlen(opt_vec[1]) - 1] = '\0';
    }
    std::string channel_id(opt_vec[1]);
    if (validate_channel_id(channel_id)) {
        return -1;
    }

    return issue_command_for_channel(OP_VERIFY_DEPOSITS, channel_id);
}

static int balance(std::vector<char*> &opt_vec) {
    if (!enough_arguments_for_command(1, opt_vec.size())) {
        usage();
        return -1;
    }

    if (opt_vec[1][strlen(opt_vec[1]) - 1] == '\n') {
        // printf("switching from \\n to \\0.\n");
        opt_vec[1][strlen(opt_vec[1]) - 1] = '\0';
    }
    std::string channel_id(opt_vec[1]);
    if (validate_channel_id(channel_id)) {
        return -1;
    }

    return issue_command_for_channel(OP_BALANCE, channel_id);
}

static int add_deposit(std::vector<char*> &opt_vec) {
    if (!enough_arguments_for_command(2, opt_vec.size())) {
        usage();
        return -1;
    }

    std::string channel_id(opt_vec[1]);
    unsigned long long deposit_id = strtoull(opt_vec[2], NULL, 10);
    if (validate_channel_id(channel_id)) {
        return -1;
    }

    struct deposit_msg_t msg;
    msg.msg_op = OP_TEECHAIN_DEPOSIT_ADD;
    memcpy(msg.channel_id, channel_id.c_str(), CHANNEL_ID_LEN);
    msg.deposit_id = deposit_id;

    send_buffer((byte*) &msg, sizeof(deposit_msg_t));
    return 0;
}

static int remove_deposit(std::vector<char*> &opt_vec) {
    if (!enough_arguments_for_command(2, opt_vec.size())) {
        usage();
        return -1;
    }

    std::string channel_id(opt_vec[1]);
    unsigned long long deposit_id = strtoull(opt_vec[2], NULL, 10);
    if (validate_channel_id(channel_id)) {
        return -1;
    }

    struct deposit_msg_t msg;
    msg.msg_op = OP_TEECHAIN_DEPOSIT_REMOVE;
    memcpy(msg.channel_id, channel_id.c_str(), CHANNEL_ID_LEN);
    msg.deposit_id = deposit_id;

    send_buffer((byte*) &msg, sizeof(deposit_msg_t));
    return 0;
}

static int send(std::vector<char*> &opt_vec) {
    if (!enough_arguments_for_command(2, opt_vec.size())) {
        usage();
        return -1;
    }

    std::string channel_id(opt_vec[1]);
    unsigned long long amount = strtoull(opt_vec[2], NULL, 10);
    if (validate_channel_id(channel_id)) {
        return -1;
    }

    if (validate_amount_to_send(amount)) {
        return -1;
    }

    struct send_msg_t msg;
    msg.msg_op = OP_SEND;
    memcpy(msg.channel_id, channel_id.c_str(), CHANNEL_ID_LEN);
    msg.amount = amount;

    send_buffer((byte*) &msg, sizeof(send_msg_t));
    wait_for_send_ack();
    return 0;
}

static int benchmark(std::vector<char*> &opt_vec) {
    if (!enough_arguments_for_command(2, opt_vec.size())) {
        usage();
        return -1;
    }

    std::string channel_id(opt_vec[1]);
    unsigned long long number_of_sends = strtoull(opt_vec[2], NULL, 10);
    if (validate_channel_id(channel_id)) {
        return -1;
    }

    unsigned long amount = 1;

    struct send_msg_t msg;
    msg.msg_op = OP_SEND;
    memcpy(msg.channel_id, channel_id.c_str(), CHANNEL_ID_LEN);
    msg.amount = amount;

    struct timeval start;
    struct timeval end;

    gettimeofday(&start, NULL);
    for (int i = 0; i < number_of_sends; i++) {
        send_buffer((byte*) &msg, sizeof(send_msg_t));
    }
    
    for (int i = 0; i < number_of_sends; i++) {
        wait_for_send_ack();
    }
    gettimeofday(&end, NULL);

    float num_milliseconds_in_sec = 1000000.0;
    float elapsed_time = (float(end.tv_sec - start.tv_sec) * num_milliseconds_in_sec) + (float(end.tv_usec - start.tv_usec));
    // printf("Total time elapsed for %d send operations: %f.\n", number_of_sends, elapsed_time);

    float txs = (number_of_sends / elapsed_time) * num_milliseconds_in_sec;
    printf("Transactions per second: %f.\n", txs);

    return 0;
}

int profile() {
    struct op_msg_t msg;
    msg.msg_op = OP_PROFILE;

    send_buffer((byte*)&msg, sizeof(op_msg_t));

    return 0;
}

int round_trip(std::vector<char*> &opt_vec) {
    if (!enough_arguments_for_command(1, opt_vec.size())) {
        usage();
        return -1;
    }

    if (opt_vec[1][strlen(opt_vec[1]) - 1] == '\n') {
        // printf("switching from \\n to \\0.\n");
        opt_vec[1][strlen(opt_vec[1]) - 1] = '\0';
    }
    std::string channel_id(opt_vec[1]);
    if (validate_channel_id(channel_id)) {
        return -1;
    }

    struct send_msg_t msg;
    msg.msg_op = OP_ROUND_TRIP;
    memcpy(msg.channel_id, channel_id.c_str(), CHANNEL_ID_LEN);

    send_buffer((byte*)&msg, sizeof(send_msg_t));

    return 0;
}

static void send_message(std::vector<char*> &opt_vec) {
#if DEBUG_MODE
    std::cout << "First Word:\n" << opt_vec[0] << std::endl;
#endif
    int res = -1;
    if (streq(opt_vec[0], "primary")) {
        res = primary(opt_vec);
    } else if (streq(opt_vec[0], "setup_deposits")) {
        res = setup_deposits(opt_vec);
    } else if (streq(opt_vec[0], "deposits_made")) {
        res = deposits_made(opt_vec);
    } else if (streq(opt_vec[0], "create_channel")) {
        res = create_channel(opt_vec);
    } else if (streq(opt_vec[0], "verify_deposits")) {
        res = verify_deposits(opt_vec);
    } else if (streq(opt_vec[0], "balance")) {
        res = balance(opt_vec);
    } else if (streq(opt_vec[0], "add_deposit")) {
        res = add_deposit(opt_vec);
    } else if (streq(opt_vec[0], "remove_deposit")) {
        res = remove_deposit(opt_vec);
    } else if (streq(opt_vec[0], "send")) {
        send(opt_vec);
    } else if (streq(opt_vec[0], "benchmark")) {
        benchmark(opt_vec);
    } else if (streq(opt_vec[0], "profile")) {
        res = profile();
    } else if (streq(opt_vec[0], "round_trip")) {
        res = round_trip(opt_vec);
    } else {
        usage();
    }
    if (res == 0) {
        size_t reply_size;
        byte* reply = recv_buffer(&reply_size);
        untrusted_teechain_read_reply(reply, reply_size);
        free(reply);
    }
}

int main(int argc, char *argv[]) {
    int ignore_valid = 0;
    if (argc < 2) {
        printf("Usage %s hostname\n", argv[0]);
        exit(-1);
    }

    if (argc >= 3) {
        if (strcmp(argv[2],"--ignore-valid") == 0) {
            ignore_valid = 1;
        }
    }
    
    client_sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (client_sockfd < 0) {
        printf("No socket\n");
        exit(-1);
    }
    server = gethostbyname(argv[1]);
    if (server == NULL) {
        printf("Can't get host\n");
        exit(-1);
    }
    server_addr.sin_family = AF_INET;
    memcpy(&server_addr.sin_addr.s_addr, server->h_addr, server->h_length);
    server_addr.sin_port = htons(DEFAULT_PORT);
    if (connect(client_sockfd, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        printf("Can't connect\n");
        exit(-1);
    }

    printf("[UT] Connected to enclave host!\n");
    
    size_t report_size;
    byte* report_buffer = recv_buffer(&report_size);
    untrusted_teechain_get_report(report_buffer, ignore_valid);
    free(report_buffer);
    
    /* Send/recv messages */
    for(;;) {
        printf("[UT] Either command for teechain operation, or q to quit\n> ");

        memset(local_buffer, 0, BUFFERLEN);
        fgets((char*)local_buffer, BUFFERLEN-1, stdin);
        printf("\n");

        /* Handle quit */
        if (local_buffer[0] == 'q' && (local_buffer[1] == '\0' || local_buffer[1] == '\n')) {
            send_exit_message();
            close(client_sockfd);
            exit(0);
        } else if (local_buffer[0] != '\0') {
            char *token = strtok((char *)local_buffer, " ");
            std::vector<char*> opt_vec;
            while (token != NULL) {
                opt_vec.push_back(token);
                token = strtok(NULL, " ");
            }
            parse_opt_init();
            std::vector<char*> opt_res;
            parse_opt(opt_vec, opt_res);
            send_message(opt_res);
        }
    }
    return 0;
}
