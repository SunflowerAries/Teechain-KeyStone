#include <stdio.h>
#include <string.h>
#include <string>
#include <iostream>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h> 
#include <unistd.h>
#include <map>
#include <vector>
#include "cmd.h"
#include "network.h"
#include "utils.h"

int fd_sock;
struct sockaddr_in server_addr;
struct hostent *server;

// remote hostname and port for the teechain node to connect to. 
static std::string remote_host(DEFAULT_HOSTNAME);
static int remote_port = 0;

// optional flags to define teechain node properties.
static bool initiator = false;
static bool use_monotonic_counters = false;
bool debug = false;
bool benchmark = false;

// parsed option index and arguments from cmdline
int opt_idx;
char *opt_arg;
std::map<char, int> opt_map;

#define BUFFERLEN 4096
byte local_buffer[BUFFERLEN];

void send_buffer(byte* buffer, size_t len) {
    write(fd_sock, &len, sizeof(size_t));
    write(fd_sock, buffer, len);
}

byte* recv_buffer(size_t* len) {
    ssize_t n_read = read(fd_sock, local_buffer, sizeof(size_t));
    if (n_read != sizeof(size_t)) {
        // Shutdown
        printf("[UT] Invalid message header\n");
        trusted_client_exit();
    }
    size_t reply_size = *(size_t*)local_buffer;
    byte* reply = (byte*)malloc(reply_size);
    if (reply == NULL) {
        // Shutdown
        printf("[UT] Message too large\n");
        trusted_client_exit();
    }
    n_read = read(fd_sock, reply, reply_size);
    if (n_read != reply_size) {
        printf("[UT] Bad message size\n");
        // Shutdown
        trusted_client_exit();
    }

    *len = reply_size;
    return reply;
}

static void usage(void) {
    std::cerr << ("Usage: command [options]\n") << std::endl;
    std::cerr << ("Teechain commands: \n"
        "quit:           Quit. \n"
        "ghost:          Creates a Teechain enclave (not yet a primary or backup). \n"
        "primary:        Assigns an existing ghost to become a primary node. \n"
        "                  Contacts localhost at port p to make assignment. \n"
        "setup_deposits: Gives a primary node the information about the number of deposits the user wishes to make. \n"
        "                  The TEE then returns a set of bitcoin addresses the user should pay into. \n"
        "deposits_made:   Gives the primary node the transaction hash of the transaction that was generated by \n"
        "                  the ownwer and paid the deposits into the primary node's bitcoin account. This requires \n"
        "                  knowing the redeem scripts to spend and the account to return funds to on settlement.\n"
        "                  This is the information presented to counter party, requiring manual verification. \n"
        "add_deposit:    Assigns an unused (but verified) deposit to a channel. When adding a deposit to a channel \n"
        "                  the adding TEE adds the funds before requiring an ack from the remote party. This is \n"
        "                  an optimization, but doesn't break safety. \n"
        "remove_deposit: Removes an assigned (but unspent) deposit from a channel. The removing TEE *must wait* \n"
        "                  for the remote TEE to ack the removal first, before removing. This is to ensure \n"
        "                  we don't break safety. \n"
        "create_channel: Creates a channel with a remote party. \n"
        "                  Both sides of the channel must have create called. \n"
        "                  The initiating side will start the message exchange process. \n"
        "                  The add_backup command uses the same message exchange protocol as here. \n"
        "verify_deposits: The manual verification step that must be performed by the user to verify that the \n"
        "                  deposit transactions presented by the remote TEE do actually exist and are actually \n"
        "                  in the blockchain. \n"
        "                  This is called on an individual channel after creation, but before sending can occur. \n"
        "                  We don't yet wait for a secure ack from the remote party (i.e. for them to establish \n"
        "                  the channel on their side -- but this is fine). \n"
        "send:           Sends a payment across a channel to the counterparty. \n"
        "settle_channel: Generate a transaction that closes a single channel and notifies the counterparty. \n"
        "                  This can only be called on the primary node. \n"
        "return_unused_deposits: Generate a transaction that returns the currently unused deposits. \n"
        "shutdown:       Settle each of the channels individually. Also generate a transaction that returns \n"
        "                  unused deposits back to the owner. \n")  << std::endl;
    exit(1);
}

static void opt_map_init(char *optstring) {
    char *p = optstring;
    while (*p != '\0') {
        if (p[1] == ':') {
            opt_map[*p] = 1;
        } else {
            opt_map[*p] = 0;
        }
        p++;
    }
}

static char parse_opt(std::vector<const char*> &opt_vec) {
    char ch;
    for (; opt_idx < opt_vec.size(); opt_idx++) {
        if (opt_vec[opt_idx][0] == '-') {
            ch = opt_vec[opt_idx][1];
            if (opt_map[opt_vec[opt_idx][1]]) {
                opt_arg = (char *)opt_vec[opt_idx + 1];
                opt_idx++;
            }
            opt_idx++;
            return ch;
        }
    }
    opt_idx = 0;
    return -1;
}

static void quit() {
    send_exit_message();
    close(fd_sock);
    exit(0);
}

static void primary(std::vector<const char*> &opt_vec) {
    struct CommandMsg msg;
    msg.msg_op[0] = OP_PRIMARY;
    msg.use_monotonic_counters = use_monotonic_counters;
    send_message((char*) &msg, sizeof(struct CommandMsg));
    size_t reply_size;
    byte* reply = recv_buffer(&reply_size);
    trusted_client_read_reply(reply, reply_size);
    free(reply);
}

static void execute_command(const char *command, std::vector<const char*> &opt_vec) {
    if (streq(command, "quit")) {
        quit();

    } else if (streq(command, "primary")) {
        primary(opt_vec);
    }
    // } else if (streq(command, "backup")) {
    //     local_backup(argc, argv);

    // } else if (streq(command, "add_backup")) {
    //     local_add_backup(argc, argv);

    // } else if (streq(command, "remove_backup")) {
    //     local_remove_backup(argc, argv);

    // } else if (streq(command, "setup_deposits")) {
    //     local_setup_deposits(argc, argv);

    // } else if (streq(command, "deposits_made")) {
    //     local_deposits_made(argc, argv);

    // } else if (streq(command, "add_deposit")) {
    //     local_add_deposit(argc, argv);

    // } else if (streq(command, "remove_deposit")) {
    //     local_remove_deposit(argc, argv);

    // } else if (streq(command, "create_channel")) {
    //     local_create_channel(argc, argv);

    // } else if (streq(command, "send")) {
    //     local_send(argc, argv);

    // } else if (streq(command, "verify_deposits")) {
    //     local_verify_deposits(argc, argv);

    // } else if (streq(command, "shutdown")) {
    //     local_shutdown(argc, argv);

    // } else if (streq(command, "return_unused")) {
    //     local_return_unused_deposits(argc, argv);

    // } else if (streq(command, "settle_channel")) {
    //     local_settle_channel(argc, argv);

    // } else if (streq(command, "present_settlement")) {
    //     local_present_settlement(argc, argv);

    // } else if (streq(command, "benchmark")) {
    //     local_benchmark(argc, argv);

    // } else if (streq(command, "balance")) {
    //     local_balance(argc, argv);
    // }
}

int main(int argc, char *argv[]) {
    int opt_ret;
    int ignore_valid = 0;
    char *cmd;
    
    if (argc < 2) {
        printf("Usage %s hostname\n", argv[0]);
        exit(-1);
    }

    if (argc >= 3) {
        if (strcmp(argv[2],"--ignore-valid") == 0) {
            ignore_valid = 1;
        }
    }
    
    fd_sock = socket(AF_INET, SOCK_STREAM, 0);
    if (fd_sock < 0) {
        printf("No socket\n");
        exit(-1);
    }
    server = gethostbyname(argv[1]);
    if (server == NULL) {
        printf("Can't get host\n");
        exit(-1);
    }
    server_addr.sin_family = AF_INET;
    memcpy(&server_addr.sin_addr.s_addr, server->h_addr, server->h_length);
    server_addr.sin_port = htons(DEFAULT_PORT);
    if (connect(fd_sock, (struct sockaddr *)&server_addr, sizeof(server_addr)) < 0) {
        printf("Can't connect\n");
        exit(-1);
    }

    printf("[UT] Connected to enclave host!\n");

    /* Establish channel */
    trusted_client_init();
    
    size_t report_size;
    byte *report_buffer = recv_buffer(&report_size);
    trusted_client_get_report(report_buffer, ignore_valid);
    free(report_buffer);

    /* Send pubkey */
    size_t pubkey_size;
    byte *pubkey = trusted_client_pubkey(&pubkey_size);
    send_buffer(pubkey, pubkey_size);

    opt_map_init("mdbir:");
    
    /* Send/recv messages */
    for(;;) {
        printf("Either command for teechain operation, or q to quit\n> ");

        memset(local_buffer, 0, BUFFERLEN);
        fgets((char*)local_buffer, BUFFERLEN-1, stdin);
        printf("\n");

        opt_idx = 0;
        char *token = strtok((char *)local_buffer, " ");
        cmd = token;
        std::vector<const char*> opt_vec;
        while (token != NULL) {
            opt_vec.push_back(token);
            token = strtok(NULL, " ");
        }

        while ((opt_ret = parse_opt(opt_vec)) != -1) {
            switch (opt_ret) {
                case 'm':
                    use_monotonic_counters = true;
                    break;
                case 'd':
                    debug = true;
                    break;
                case 'b':
                    benchmark = true;
                    break;
                case 'i':
                    initiator = true;
                    break;
                case 'r': {
                    char *host_and_port= opt_arg;
                    char *token;
                    const char *colon = ":";
                    token = strtok(host_and_port, colon);
                    remote_host = std::string(token);
                    token = strtok(NULL, colon);
                    remote_port = atoi(token);
                    break;
                }
                default:
                    usage();
            }
        }

        execute_command(cmd, opt_vec);
    }
    return 0;
}
